---
title: "How I Uses LLMs (Oct)"
date: "Tue Oct 21 2025 08:00:00 GMT+0800 (Singapore Standard Time)"
---

继前述[How I Uses LLMs](/posts/how-I-use-llms)不过八个月而已，但好像已经过去了几个世纪，与八个月前最为不同的是，写代码变成了我日常使用LLM最多的场景，所以之前的一些观点现在都不适用了，是时候来重新记录一下。

在代码生成这件事上，Claude老师直到GPT-5发布之前一直拥有代际优势，所以一开始我使用的工具都是围绕Claude老师展开的，比如Claude官方前端的artifacts或是Claude Code，以及[Replit](https://replit.com/refer/2011txy)这种基于Claude的应用生成平台。直到我决定做一个自己的套壳（至于为什么要做套壳，值得单独写一篇）。我的套壳历程经历了两次大的变更，一开始我打算做个桌面应用，这样可以用到很多系统能力，比如在Macbook上应用图标可以在菜单栏常驻。这一阶段我主要使用的是[Claude Code](https://docs.claude.com/en/docs/claude-code/overview)。最近两个月我抛弃之前的桌面端，重新vibe出来一个网页应用[Moana](https://moana.xytang.me)，主要使用Cursor。以下是一些经验和教训：

- 一次性代码无脑一句话生成：现在的模型one shot出来一个可用的小脚本或者小的网页应用，大都非常够用，有事没事整点小工具，可以大幅提升自己的幸福感。
- 自己需要会写代码吗：不需要能写，但如果不是一次性代码，一定需要能看。如果要类比职场中的角色，vibe coder基本等同于engineering manager，不一定自己亲手写代码，但最好能看懂组员在做什么。不过看“懂”是个很抽象的说法，可以是每行代码都知道是在干什么，也可以是只了解代码的结构，全凭个人喜好，最重要是通过大量的练习，找到自己的舒适区。
- 补全还是agent：对于需要持续维护的代码库，如果是一个全新的项目，就不能让agent完全自己发挥，只能借助补全来逐步迭代直到代码结构趋于稳定，agent能通过查看当前代码结构来约束生成结果。
- Plan mode: 小的变动可以一把梭哈的就不用plan了，在添加一个全新的feature时很有必要，但plan好的前提还是能看懂代码。
- Background agent: 非资深程序员慎用，很容易等半天等来一个不能用的结果还得推翻重来，如果将错就错修修补补，一不小心就错的越来越远。
- 用什么模型：无脑使用Claude老师的年代过去了，gpt-5已迎头赶上甚至略微超车，甚至glm也能凑合用，不同价位不同效果任君挑选。
- 量变引起质变：以上都是观点，实际还得自己动手，毕竟生成这件事是non-deterministic的，没有哪个评测可以替代自己的体感，唯有大量的用，才能找到自己的舒适区

代码之外，跟之前最大的不同有两点

- 已经基本不使用Perplexity。在少数需要搜索的场景，首选是Gemini的search grounding。Gemini的效果赶上来之后，结合谷歌生态，纯搜索也不用其他选项了。（题外话：Perplexity也开始走差异化路线了，不再只盯着搜索和谷歌打，很聪明）
- 从不使用三方套壳，到自己做了个套壳[Moana](https://moana.xytang.me)。对于绝大多数的场景，维持原判aka官方\>\>\>\>\>\>\>\>套壳。但如果像我这样有非常个性化的交互需求，非常建议自己做一个套壳，可以从零开始做也可以基于开源产品进行改造，亲手实现出来自己迫切需要但所有的官方都没有做的功能。我给自己加上的包括不限于
  - Workspace: 用于隔离工作和非工作项目的数据
  - Markdown标题折叠：妈妈再也不用担心上下翻页的时候不知道翻到哪里了
  - Save to Readwise: 一键将答案保存至Readwise，再同步到Heptabase
  - Branch: 通过分支来保存同个对话中的不同答案，再也不用新答案overwrite旧答案了
  - Breadcrumb: 信息结构更加清晰，导航更加容易不完全依赖侧边栏

除上述内容以外，观点跟之前基本一致

EOF